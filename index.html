
<!--Div auxiliar para introducir el texto de una clave justo al agregarla-->
<div id="editKeys" style="background:transparent; padding-left:53px; position:absolute; z-index:9999999; display:none;">
	<textarea style="resize: none;" id="editKeysInput" wrap="hard" rows="3" cols="50"></textarea></br>
	<button style="float:right" onclick="saveKey()">Save</button>
	<button style="float:right" onclick="closeKeyEdit()">Close</button>
</div>

<!--Div para mostrar las claves y sus textos en una ventana con drag-->
<div id="AllKeysDiv"
	style="border:4px solid black; padding: 10px; background-color:white; position:absolute; z-index:9999999; top:20px; left:20px; max-width:50vw; display:none;">
</div>


<div style="display:flex; align-items:flex-start">

	<!--Div para almacenar todas las herramientas de edicion de mapa-->
	<div style="display:flex; min-width:fit-content; flex-direction:column; padding:5px 10px 5px 5px; border:4px solid black; margin: 10px; background-color:white; z-index:999; min-height:calc(100vh - 54px);">
		<h2 style="text-align:center">&#9773;</h2>
		<div>
			<h3>Tools</h3>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="empty" id="interesado" checked> <label
				for="interesado">Vaciar</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="fill" id="indeciso"> <label
				for="indeciso">Rellenar</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="key" id="key"> <label
				for="key">Clave</label><input type="number" style="margin-left:15px; width:60px;" id="dungeonKey"></input>
			</br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="door" id="door"> <label
				for="door">Puerta</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="window" id="window"> <label
				for="window">Ventana</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="sdoor" id="sdoor"> <label
				for="sdoor">Puerta S.</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="trap" id="trap"> <label
				for="trap">Trampa</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="stairDown" id="stairDown"> <label
				for="stairDown">Escalera Descendente</label> </br>
			<div id="subSDown" style="display:none; margin-left:20px">
				<input checked type="radio" name="subSDown" value="north" id="north"> <label for="north">&#8593</label>
				</br>
				<input type="radio" name="subSDown" value="south" id="south"> <label for="south">&#8595</label> </br>
				<input type="radio" name="subSDown" value="left" id="left"> <label for="left">&#8592</label> </br>
				<input type="radio" name="subSDown" value="right" id="right"> <label for="right">&#8594</label> </br>
			</div>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="stairUp" id="stairUp"> <label
				for="stairUp">Escalera Ascendente</label> </br>
			<div id="subSUp" style="display:none; margin-left:20px">
				<input checked type="radio" name="subSUp" value="north" id="north"> <label for="north">&#8593</label> </br>
				<input type="radio" name="subSUp" value="south" id="south"> <label for="south">&#8595</label> </br>
				<input type="radio" name="subSUp" value="left" id="left"> <label for="left">&#8592</label> </br>
				<input type="radio" name="subSUp" value="right" id="right"> <label for="right">&#8594</label> </br>
			</div>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="column" id="column"> <label
				for="column">Columna</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="wall" id="wall"> <label
				for="wall">Muro</label> </br>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="eraser" id="eraser"> <label
				for="eraser">Eraser...</label> </br>
			<div id="subEraser" style="display:none; margin-left:20px">
				<input checked type="radio" name="subEraser" value="big" id="big"> <label for="big">Big</label> </br>
				<input type="radio" name="subEraser" value="small" id="small"> <label for="small">Small</label> </br>
				<input type="radio" name="subEraser" value="object" id="object"> <label for="object">Object</label> </br>
				<input type="radio" name="subEraser" value="dungeon" id="dungeon"> <label for="dungeon">Dungeon</label>
				</br>
			</div>
			<input onclick="changeTool(this.value)" type="radio" name="mode" value="token" id="token"> <label
				for="token">Tokens...</label> </br>
			<div id="subTokens" style="display:none">
				<input type="radio" name="subTokens" value="0" id="t0" style="margin-left:20px" checked> <label
					for="t0">T0</label> <input type="text" style="margin-left:15px; width:25px;" id="t0T" value="G"
					maxlength="1"></input> </br>
				<input type="radio" name="subTokens" value="1" id="t1" style="margin-left:20px"> <label for="t1">T1</label>
				<input type="text" style="margin-left:15px; width:25px;" id="t1T" value="E" maxlength="1"></input> </br>
				<input type="radio" name="subTokens" value="2" id="t2" style="margin-left:20px"> <label for="t2">T2</label>
				<input type="text" style="margin-left:15px; width:25px;" id="t2T" value="T" maxlength="1"></input> </br>
				<input type="radio" name="subTokens" value="3" id="t3" style="margin-left:20px"> <label for="t3">T3</label>
				<input type="text" style="margin-left:15px; width:25px;" id="t3T" value="R" maxlength="1"></input> </br>
			</div>
		</div>
		<div style="display:flex; flex-direction:column">
			<h3>Settings</h3>
			<button onclick="ToggleGrid()">Toggle Grid</button>
			<button onclick="ToggleGridLines()">Toggle Grid Lines</button>
			<button onclick="exporter()">Export</button>
			<button onclick="importerButton()">Import</button>
			<button onclick="download()">Download</button>
			<button onclick="undo()">Undo</button>
			<button onclick="showAllKeys()">Show Keys</button>
		</div>
		<h3 style="cursor:pointer" onclick="ToggleStyles()">Change Style +</h3>
		<div id="estilos" style="display:none; flex-direction:column">
			<input type="text" id="filledColor"></input> <button onclick="changeFColor()" style="margin-bottom:15px;">Change filled</button>
			<input type="text" id="emptyColor"></input> <button onclick="changeEColor()" style="margin-bottom:15px;">Change empty</button>
			<input type="text" id="strokeColor"></input> <button onclick="changeSColor()" style="margin-bottom:15px;">Change stroke</button>
			<input type="text" id="interColor"></input> <button onclick="changeIColor()" style="margin-bottom:15px;">Change square separation</button>
			<input type="text" id="gridColor"></input> <button onclick="changeGColor()" style="margin-bottom:15px;">Change grid</button>
		</div>
	</div>

	<!--Divs necesarios para el renderizado del mapa-->
	<div style="position:relative; margin:10px 0px; border:3px solid black; overflow:scroll; width:100%; max-height:calc(100vh - 42px);">

		<canvas id="dungeonC" width="1439px" height="1439px">

		</canvas>

		<canvas id="objects" width="1439px" height="1439px" style="position:absolute; top:0px; left:0px;">

		</canvas>

		<canvas id="casillero" width="1439px" height="1439px"
			style="opacity:0.8; display:none; position:absolute; top:0px; left:0px;">

		</canvas>

		<canvas id="tokensCanvas" width="1439px" height="1439px" style="opacity:0.8; position:absolute; top:0px; left:0px;">

		</canvas>

		<canvas id="cuadraditos" width="1439px" height="1439px" style="opacity:0.8; position:absolute; top:0px; left:0px;">

		</canvas>
	</div>

	<!--Div para chat y lanzador de dados WIP-->
	<div id="chatPanel" style="justify-content: flex-start; display:flex; flex-direction:column; padding:5px; border:4px solid black; margin:10px; width: 200pt; background-color:white; z-index:999; height:calc(100vh - 54px);">
		<h2 style="text-align:center; margin-bottom:10px;">Chat & Roll</h2>
		<div style="display:flex; justify-content:center; align-items:center; margin-bottom: 15px;"><div onclick="changeNameColor()"  id="chatColor" style="height:75%; margin-right:10px; cursor:pointer; border-radius: 100%; aspect-ratio: 1/1; background-color: black;"></div><input id="chatName" placeholder="Input your Name" type="text"> <span id="saveName" style="display: none; cursor:pointer; padding: 0px 0px 3px 5px;" onclick="nametoCookie()">ðŸ’¾</span></div>
		<div id="logBoxTop"> - Top - </div>
		<div id="logBox">
		</div>
		<div id="modifiersBox" style="display:none">
			<div>
				<button onclick="rollDices('1d20+5')">+5</button>
				<button onclick="rollDices('1d12+5')">+5</button>
				<button onclick="rollDices('1d10+5')">+5</button>
				<button onclick="rollDices('1d8+5')">+5</button>
				<button onclick="rollDices('1d6+5')">+5</button>
				<button onclick="rollDices('1d4+5')">+5</button>
				<button onclick="rollDices('1d100+5')">+5</button>
			</div>
			<div>
				<button onclick="rollDices('1d20+4')">+4</button>
				<button onclick="rollDices('1d12+4')">+4</button>
				<button onclick="rollDices('1d10+4')">+4</button>
				<button onclick="rollDices('1d7+4')">+4</button>
				<button onclick="rollDices('1d6+4')">+4</button>
				<button onclick="rollDices('1d4+4')">+4</button>
				<button onclick="rollDices('1d100+4')">+4</button>
			</div>
			<div>
				<button onclick="rollDices('1d20+3')">+3</button>
				<button onclick="rollDices('1d12+3')">+3</button>
				<button onclick="rollDices('1d10+3')">+3</button>
				<button onclick="rollDices('1d8+3')">+3</button>
				<button onclick="rollDices('1d6+3')">+3</button>
				<button onclick="rollDices('1d4+3')">+3</button>
				<button onclick="rollDices('1d100+3')">+3</button>
			</div>
			<div>
				<button onclick="rollDices('1d20+2')">+2</button>
				<button onclick="rollDices('1d12+2')">+2</button>
				<button onclick="rollDices('1d10+2')">+2</button>
				<button onclick="rollDices('1d8+2')">+2</button>
				<button onclick="rollDices('1d6+2')">+2</button>
				<button onclick="rollDices('1d4+2')">+2</button>
				<button onclick="rollDices('1d100+2')">+2</button>
			</div>
			<div>
				<button onclick="rollDices('1d20+1')">+1</button>
				<button onclick="rollDices('1d12+1')">+1</button>
				<button onclick="rollDices('1d10+1')">+1</button>
				<button onclick="rollDices('1d8+1')">+1</button>
				<button onclick="rollDices('1d6+1')">+1</button>
				<button onclick="rollDices('1d4+1')">+1</button>
				<button onclick="rollDices('1d100+1')">+1</button>
			</div>
		</div>
		<div id="rollBox">
			<button onclick="rollDices('1d20')">20</button>
			<button onclick="rollDices('1d12')">12</button>
			<button onclick="rollDices('1d10')">10</button>
			<button onclick="rollDices('1d8')">8</button>
			<button onclick="rollDices('1d6')">6</button>
			<button onclick="rollDices('1d4')">4</button>
			<button onclick="rollDices('1d100')">%</button>
		</div>
		<h4 id="modifiersTitle" style="margin:0px; width:100%; text-align:center; cursor:pointer;" onclick="ToggleModifiers()">+ Show Modifiers +</h4>
		<div id="chatBox">
			<input type="text" id="msgInput">
			<button onclick="sendMsg()">>></button>
		</div>
	</div>

</div>

<script type="text/javascript" language="javascript">

	// Box width
	var bw = 1440;
	// Box height
	var bh = 1440;
	// Numero de casillas de ancho
	var numCasX = 45;
	// Numero de casillas de alto
	var numCasY = 45;
	// Pixels por casilla de lado
	var pxCas = 32;

	var click = false;
	var dragdrop = false;

	var selectedTool = "empty";



	// Undo function
	// ----------------------
	var undoArray = new Array();
	var undoDungeon = new Array();
	var undoObjects = new Array();


	// Colors
	//------------------------
	var interColor = "darkgray";
	var strokeColor = "black";
	var emptyColor = "lightgray";
	var filledColor = "darkgray";
	var gridColor = "lightblue";

	// Settings
	//------------------------
	var middleDots = true;
	var radioChanger = document.querySelector('input[name="mode"]:checked');
	var showGridLine = true;



	// Canvas handlers
	//-------------------------
	var elCasillero = document.getElementById("casillero");
	var laDungeon = document.getElementById("dungeonC");
	var cuadraditos = document.getElementById("cuadraditos");
	var objectC = document.getElementById("objects");

	var contextDungeon = laDungeon.getContext("2d");
	var contextCasillero = elCasillero.getContext("2d");
	var contextCuadraditos = cuadraditos.getContext("2d");
	var contextObject = objectC.getContext("2d");
	var contextToken = document.getElementById("tokensCanvas").getContext("2d");


	// Contenido de casillas
	//----------------------
	// 1: puerta
	// 2: puerta secreta
	// 3: muro
	// 4: trampa
	// 5: columna
	// 6: ventana
	// 7: stairs up north
	// 8: stairs up right
	// 9: stairs up south
	// 10: stairs up left
	// 11: stairs down north
	// 12: stairs down right
	// 13: stairs down south
	// 14: stairs down left
	//-----------------------

	var dungeonFilled = {};
	var dungeonObject = {};
	var fullKeys = {};
	var currentKey;

	contextDungeon.fillStyle = filledColor;

	for (var x = 0; x < numCasX; x++) {
		for (var y = 0; y < numCasY; y++) {
			var aider = [x, y];
			dungeonFilled[aider] = false;
			contextDungeon.fillRect(x * 32, y * 32, 32, 32);
		}
	}
	for (var x = 0; x < numCasX; x++) {
		for (var y = 0; y < numCasY; y++) {
			var aider = [x, y];
			dungeonObject[aider] = 0;
		}
	}

	var casillaSeleccionada;


	// Token: [nombre, color, casilla, activo]
	var tokens = new Array(
		{ name: "G", color: "blue", casilla: null, activo: false },
		{ name: "E", color: "red", casilla: null, activo: false },
		{ name: "T", color: "yellow", casilla: null, activo: false },
		{ name: "R", color: "green", casilla: null, activo: false }
	);


	// Cargar Dungeon
	//----------------------------
	function cargarDungeon() {
		const d = new Date();
		let time = d.getTime();
		contextDungeon.clearRect(0, 0, dungeon.width, dungeon.height);
		contextObject.clearRect(0, 0, dungeon.width, dungeon.height);
		for (var x = 0; x < numCasX; x += 0.5) {
			for (var y = 0; y < numCasY; y += 0.5) {
				casillaSeleccionada = new Array(x, y);
				if (!isBorderX() && !isBorderY()) {
					actualizarCasilla(casillaSeleccionada)
				}
				if (dungeonObject[casillaSeleccionada] != 0) {
					actualizarObjeto(casillaSeleccionada, dungeonObject[casillaSeleccionada]);
				}
			}
		}
		undoArray = new Array();
		const e = new Date();
		let time2 = e.getTime();
		console.log(time2 - time);
	}


	// Dibuja la cuadricula
	//----------------------------
	function drawBoard() {
		for (var x = 0.5; x <= bw; x += 32) {
			contextCasillero.moveTo(x, 0.5);
			contextCasillero.lineTo(x, bh + 0.5);
		}

		for (var y = 0.5; y <= bh; y += 32) {
			contextCasillero.moveTo(0.5, y);
			contextCasillero.lineTo(bw + 0.5, y);
		}
		contextCasillero.strokeStyle = gridColor;
		contextCasillero.stroke();
	}


	// Pinta la casilla en la que esta el cursor
	//----------------------------
	function markSquare(x, y) {

		casillaSeleccionada = getSquarefromCoordinates(x, y);
		pintarCasilla(contextCuadraditos, casillaSeleccionada, gridColor);
	}


	// Pinta una casilla
	// Casilla es un array con coordenadas de casilla
	//----------------------------
	function pintarCasilla(contexto, casilla, color) {
		contexto.fillStyle = color;
		if (!isBorderX() && !isBorderY()) {
			var casX = casilla[0] * 32;
			var casY = casilla[1] * 32;
			contexto.fillRect(casX, casY, 32, 32);
		} else {
			if (isBorderY()) {
				var casX = (casilla[0]) * 32;
				var casY = (casilla[1] - 0.5) * 32;
				contexto.fillRect(casX + 1.5, casY + 30.5, 30, 5);
			} else {
				var casX = (casilla[0] - 0.5) * 32;
				var casY = casilla[1] * 32;
				contexto.fillRect(casX + 30.5, casY + 1.5, 5, 30);
			}
		}

	}


	// Averigua si es casilla o arista
	//----------------------------------------------------
	function isBorderX(casilla = casillaSeleccionada) {
		if (Math.floor(casilla[0]) - casilla[0] == 0) {
			return false;
		}
		return true;
	}

	function isBorderY(casilla = casillaSeleccionada) {
		if (Math.floor(casilla[1]) - casilla[1] == 0) {
			return false;
		}
		return true;
	}



	// Devuelve una casilla recibiendo coordenadas de raton
	//----------------------------
	function getSquarefromCoordinates(x, y) {

		var casX = (x * numCasX) / bw;
		casX = Math.floor(casX);

		var casY = (y * numCasY) / bh;
		casY = Math.floor(casY);

		if (x > (casX * 32) + 4 && x < (casX * 32) + 28 && y > (casY * 32) + 4 && y < (casY * 32) + 28 && (document.querySelector('input[name="mode"]:checked').value == "wall")) {
			return false;
		}

		if (
			document.querySelector('input[name="mode"]:checked').value == "wall" ||
			document.querySelector('input[name="mode"]:checked').value == "column" ||
			document.querySelector('input[name="mode"]:checked').value == "door" ||
			document.querySelector('input[name="mode"]:checked').value == "sdoor" ||
			document.querySelector('input[name="mode"]:checked').value == "window" ||
			document.querySelector('input[name="mode"]:checked').value == "trap" ||
			(document.querySelector('input[name="mode"]:checked').value == "eraser" && document.querySelector('input[name="subEraser"]:checked').value == "object")
		) {
			if (x > (casX * 32) + 4 && x < (casX * 32) + 28 && (y < (casY * 32) + 7 || y > (casY * 32) + 25)) {
				if (y > (casY * 32) + 25) {
					casY = casY + 0.5;
				} else {
					casY = casY - 0.5;
				}
			} else {
				if (x < (casX * 32) + 7) {
					casX = casX - 0.5;
				}
				if (x > (casX * 32) + 25) {
					casX = casX + 0.5;
				}
			}
		}


		casCoords = [casX, casY];

		return casCoords;
	}

	// Coge las coordenadas del cursor
	//----------------------------
	cuadraditos.addEventListener("mousemove", function (e) {
		var cRect = cuadraditos.getBoundingClientRect();
		var x = Math.round(e.clientX - cRect.left);
		var y = Math.round(e.clientY - cRect.top);
		if (casillaSeleccionada == null || (getSquarefromCoordinates(x, y) != false && (casillaSeleccionada[0] != getSquarefromCoordinates(x, y)[0] || casillaSeleccionada[1] != getSquarefromCoordinates(x, y)[1]))) {

			contextCuadraditos.clearRect(0, 0, cuadraditos.width, cuadraditos.height);
			if (selectedTool == "eraser" && document.querySelector('input[name="subEraser"]:checked').value == "big") {
				markSquare(x - 32, y - 32);
				markSquare(x - 32, y);
				markSquare(x - 32, y + 32);
				markSquare(x, y - 32);
				markSquare(x, y + 32);
				markSquare(x + 32, y - 32);
				markSquare(x + 32, y);
				markSquare(x + 32, y + 32);
				markSquare(x, y);
			} else {
				markSquare(x, y);
			}
			if (click) {
				transformarCasilla();
			}
		}
	});


	// Registra los clics
	//----------------------------
	cuadraditos.addEventListener("mousedown", function (e) {
		if (e.button != 0) {
			return;
		}
		e.preventDefault();

		click = true;
		transformarCasilla();
	});

	cuadraditos.addEventListener("mouseup", function (e) {
		click = false;
	});

	cuadraditos.addEventListener("mouseout", function (e) {
		click = false;
	});






	// Drag and Drop??
	document.getElementById("AllKeysDiv").addEventListener("mousedown", function (e) {
		if (e.button != 0) {
			return;
		}
		e.preventDefault();
		dragdrop = true;
	});

	document.getElementById("AllKeysDiv").addEventListener("mouseup", function (e) {
		dragdrop = false;
	});

	document.addEventListener("mouseleave", function (e) {
		dragdrop = false;
	});

	document.addEventListener("mousemove", function (e) {
		if (dragdrop) {
			var div = document.getElementById("AllKeysDiv").getBoundingClientRect();
			console.log("client = " + e.clientX + " and div = " + div.left);
			document.getElementById("AllKeysDiv").style.left = e.clientX - 20;
			console.log((e.clientX - div.left) + " should be equal to " + document.getElementById("AllKeysDiv").style.left);
			document.getElementById("AllKeysDiv").style.top = e.clientY - 20;
		}
	});


	// Pintar en casilla
	//----------------------------
	function transformarCasilla() {

		switch (document.querySelector('input[name="mode"]:checked').value) {
			case "empty":
				pintarCasilla(contextDungeon, casillaSeleccionada, emptyColor);
				undoArray.push(new Array("dun", casillaSeleccionada, dungeonFilled[casillaSeleccionada]));
				dungeonFilled[casillaSeleccionada] = true;
				actualizarCasilla(casillaSeleccionada);
				break;

			case "fill":
				pintarCasilla(contextDungeon, casillaSeleccionada, filledColor);
				undoArray.push(new Array("dun", casillaSeleccionada, dungeonFilled[casillaSeleccionada]));
				dungeonFilled[casillaSeleccionada] = false;
				actualizarCasilla(casillaSeleccionada);
				break;

			case "key":
				if (parseInt(document.getElementById("dungeonKey").value) > 0) {
					actualizarObjeto(casillaSeleccionada, 100 + parseInt(document.getElementById("dungeonKey").value));
				} else {
					openFullKey(casillaSeleccionada);
				}
				break;

			case "door":
				actualizarObjeto(casillaSeleccionada, 1);
				break;

			case "window":
				actualizarObjeto(casillaSeleccionada, 6);
				break;

			case "sdoor":
				actualizarObjeto(casillaSeleccionada, 2);
				break;

			case "stairUp":
				switch (document.querySelector('input[name="subSUp"]:checked').value) {
					case "north":
						actualizarObjeto(casillaSeleccionada, 7);
						break;

					case "south":
						actualizarObjeto(casillaSeleccionada, 8);
						break;

					case "left":
						actualizarObjeto(casillaSeleccionada, 9);
						break;

					case "right":
						actualizarObjeto(casillaSeleccionada, 10);
						break;
				}
				break;

			case "stairDown":
				switch (document.querySelector('input[name="subSDown"]:checked').value) {
					case "north":
						actualizarObjeto(casillaSeleccionada, 11);
						break;

					case "south":
						actualizarObjeto(casillaSeleccionada, 12);
						break;

					case "left":
						actualizarObjeto(casillaSeleccionada, 13);
						break;

					case "right":
						actualizarObjeto(casillaSeleccionada, 14);
						break;
				}
				break;

			case "trap":
				actualizarObjeto(casillaSeleccionada, 4);
				break;

			case "wall":
				actualizarObjeto(casillaSeleccionada, 3);
				break;

			case "column":
				actualizarObjeto(casillaSeleccionada, 5);
				break;

			case "eraser":
				switch (document.querySelector('input[name="subEraser"]:checked').value) {
					case "big":
						bigEraser();
						break;

					case "object":
						objectEraser();
						break;

					case "small":
						smallEraser();
						break;

					case "dungeon":
						dungeonEraser();
						break;
				}
				break;

			case "token":
				paintToken();
				break;

		}
	}


	// Deshacer
	//-------------------------------
	function undo() {
		if (undoArray.length < 1) {
			return;
		}
		var theUndo = undoArray.pop();
		if (theUndo[0] == "dun") {
			dungeonFilled[theUndo[1]] = theUndo[2];
			actualizarCasilla(theUndo[1]);
		} else {
			actualizarObjeto(theUndo[1], theUndo[2], false);
		}
	}

	function paintSingleSquare(casilla, corner) {
		var coordCasilla = [casilla[0], casilla[1]];
		coordCasilla[0] = (coordCasilla[0] * 32);
		coordCasilla[1] = (coordCasilla[1] * 32);
		// Paint the selected square
		if (dungeonFilled[casilla]) {
			contextDungeon.fillStyle = emptyColor;
		} else {
			contextDungeon.fillStyle = filledColor;
		}
		contextDungeon.fillRect(coordCasilla[0], coordCasilla[1], 32, 32);


		//Pintar intercasillado
		if (showGridLine) {
			contextDungeon.fillStyle = interColor;
			// North
			if ((dungeonFilled[new Array(casilla[0], casilla[1] - 1)] || dungeonFilled[casilla]) && casilla[1] != 0 && dungeonFilled[new Array(casilla[0], casilla[1] - 1)] == dungeonFilled[casilla]) {
				contextDungeon.fillRect(coordCasilla[0] + 6, coordCasilla[1], 20, 1);
			}
			// East
			if ((dungeonFilled[new Array(casilla[0] + 1, casilla[1])] || dungeonFilled[casilla]) && casilla[0] != numCasX && dungeonFilled[new Array(casilla[0] + 1, casilla[1])] == dungeonFilled[casilla]) {
				contextDungeon.fillRect(coordCasilla[0] + 31, coordCasilla[1] + 6, 1, 20);
			}
			// South
			if ((dungeonFilled[new Array(casilla[0], casilla[1] + 1)] || dungeonFilled[casilla]) && casilla[1] != numCasY && dungeonFilled[new Array(casilla[0], casilla[1] + 1)] == dungeonFilled[casilla]) {
				contextDungeon.fillRect(coordCasilla[0] + 6, coordCasilla[1] + 31, 20, 1);
			}
			// West
			if ((dungeonFilled[new Array(casilla[0] - 1, casilla[1])] || dungeonFilled[casilla]) && casilla[0] != 0 && dungeonFilled[new Array(casilla[0] - 1, casilla[1])] == dungeonFilled[casilla]) {
				contextDungeon.fillRect(coordCasilla[0], coordCasilla[1] + 6, 1, 20);
			}
		}



		// Pintar muros

		contextDungeon.fillStyle = strokeColor;
		// North
		if ((dungeonFilled[new Array(casilla[0], casilla[1] - 1)] || dungeonFilled[casilla]) && casilla[1] != 0 && dungeonFilled[new Array(casilla[0], casilla[1] - 1)] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0], coordCasilla[1], 32, 1.5);
		}
		// East
		if ((dungeonFilled[new Array(casilla[0] + 1, casilla[1])] || dungeonFilled[casilla]) && casilla[0] != numCasX && dungeonFilled[new Array(casilla[0] + 1, casilla[1])] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0] + 32 - 1.5, coordCasilla[1], 1.5, 32);
		}
		// South
		if ((dungeonFilled[new Array(casilla[0], casilla[1] + 1)] || dungeonFilled[casilla]) && casilla[1] != numCasY && dungeonFilled[new Array(casilla[0], casilla[1] + 1)] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0], coordCasilla[1] + 32 - 1.5, 32, 1.5);
		}
		// West
		if ((dungeonFilled[new Array(casilla[0] - 1, casilla[1])] || dungeonFilled[casilla]) && casilla[0] != 0 && dungeonFilled[new Array(casilla[0] - 1, casilla[1])] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0], coordCasilla[1], 1.5, 32);
		}


		// Pintar esquinas de muros

		// North-East
		if (casilla[1] != 0 && casilla[0] != numCasX && dungeonFilled[new Array(casilla[0] + 1, casilla[1] - 1)] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0] + 32 - 1.5, coordCasilla[1], 1.5, 1.5);
		}
		// South-East
		if (casilla[1] != numCasY && casilla[0] != numCasX && dungeonFilled[new Array(casilla[0] + 1, casilla[1] + 1)] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0] + 32 - 1.5, coordCasilla[1] + 32 - 1.5, 1.5, 1.5);
		}
		// South-West
		if (casilla[1] != numCasY && casilla[0] != 0 && dungeonFilled[new Array(casilla[0] - 1, casilla[1] + 1)] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0], coordCasilla[1] + 32 - 1.5, 1.5, 1.5);
		}
		// North-West
		if (casilla[1] != 0 && casilla[0] != 0 && dungeonFilled[new Array(casilla[0] - 1, casilla[1] - 1)] != dungeonFilled[casilla]) {
			contextDungeon.fillRect(coordCasilla[0], coordCasilla[1], 1.5, 1.5);
		}
	}

	function actualizarCasilla(casilla) {

		paintSingleSquare(casilla, false);
		paintSingleSquare(new Array(casilla[0] - 1, casilla[1]), false);
		paintSingleSquare(new Array(casilla[0], casilla[1] + 1), false);
		paintSingleSquare(new Array(casilla[0] + 1, casilla[1]), false);
		paintSingleSquare(new Array(casilla[0], casilla[1] - 1), false);

		paintSingleSquare(new Array(casilla[0] + 1, casilla[1] - 1), true);
		paintSingleSquare(new Array(casilla[0] - 1, casilla[1] - 1), true);
		paintSingleSquare(new Array(casilla[0] + 1, casilla[1] + 1), true);
		paintSingleSquare(new Array(casilla[0] - 1, casilla[1] + 1), true);

	}

	function actualizarObjeto(casilla, objectNum, logUndo = true) {
		if (logUndo) {
			undoArray.push(new Array("obj", casilla, dungeonObject[casilla]));
		}
		if (dungeonObject[casilla] != 0) {
			if (!isBorderX(casilla) && !isBorderY(casilla)) {
				var casillasAdyacentes = [
					new Array(casilla[0] - 0.5, casilla[1]),
					new Array(casilla[0] + 0.5, casilla[1]),
					new Array(casilla[0], casilla[1] + 0.5),
					new Array(casilla[0], casilla[1] - 0.5)
				];
				contextObject.clearRect(casilla[0] * 32, casilla[1] * 32, 32, 32);
			}
			if (isBorderX(casilla)) {
				var casillasAdyacentes = [
					new Array(casilla[0] - 0.5, casilla[1]),
					new Array(casilla[0] + 0.5, casilla[1]),
					new Array(casilla[0] + 0.5, casilla[1] + 0.5),
					new Array(casilla[0] + 0.5, casilla[1] - 0.5),
					new Array(casilla[0] - 0.5, casilla[1] + 0.5),
					new Array(casilla[0] - 0.5, casilla[1] - 0.5)
				];
				contextObject.clearRect(((casilla[0] + 0.5) * 32) - 16, casilla[1] * 32, 32, 32);
			}
			if (isBorderY(casilla)) {
				var casillasAdyacentes = [
					new Array(casilla[0], casilla[1] + 0.5),
					new Array(casilla[0], casilla[1] - 0.5),
					new Array(casilla[0] + 0.5, casilla[1] + 0.5),
					new Array(casilla[0] + 0.5, casilla[1] - 0.5),
					new Array(casilla[0] - 0.5, casilla[1] + 0.5),
					new Array(casilla[0] - 0.5, casilla[1] - 0.5)
				];
				contextObject.clearRect(casilla[0] * 32, ((casilla[1] + 0.5) * 32) - 16, 32, 32);
			}

			casillasAdyacentes.forEach((adjCas, i) => {
				pintarObjeto(adjCas);
			});
		}
		dungeonObject[casilla] = objectNum;
		pintarObjeto(casilla);
	}

	function pintarObjeto(casilla) {
		contextObject.fillStyle = strokeColor;
		switch (dungeonObject[casilla]) {
			case 1: //Door
				contextObject.fillStyle = strokeColor;
				if (isBorderX(casilla) || isBorderY(casilla)) {
					if (isBorderX(casilla)) {
						contextObject.fillRect((casilla[0] * pxCas) - 1.5 + 16, casilla[1] * pxCas, 3, pxCas);
						contextObject.fillRect((casilla[0] * pxCas) + 16 - 6, casilla[1] * pxCas + 5, 12, pxCas - 10);
						contextObject.fillStyle = emptyColor;
						contextObject.fillRect((casilla[0] * pxCas) + 16 - 3, casilla[1] * pxCas + 8, 6, pxCas - 16);
					} else {
						contextObject.fillRect((casilla[0] * pxCas), casilla[1] * pxCas - 1.5 + 16, pxCas, 3);
						contextObject.fillRect((casilla[0] * pxCas) + 5, casilla[1] * pxCas + 16 - 6, pxCas - 10, 12);
						contextObject.fillStyle = emptyColor;
						contextObject.fillRect((casilla[0] * pxCas) + 8, casilla[1] * pxCas + 16 - 3, pxCas - 16, 6);
					}
				} else {
					if (!dungeonFilled[new Array(casilla[0], casilla[1] - 1)] && !dungeonFilled[new Array(casilla[0], casilla[1] + 1)]) {
						contextObject.fillRect((casilla[0] * pxCas) - 1.5 + 16, casilla[1] * pxCas, 3, pxCas);
						contextObject.fillRect((casilla[0] * pxCas) + 16 - 6, casilla[1] * pxCas + 5, 12, pxCas - 10);
						contextObject.fillStyle = emptyColor;
						contextObject.fillRect((casilla[0] * pxCas) + 16 - 3, casilla[1] * pxCas + 8, 6, pxCas - 16);
					} else {
						contextObject.fillRect((casilla[0] * pxCas), casilla[1] * pxCas - 1.5 + 16, pxCas, 3);
						contextObject.fillRect((casilla[0] * pxCas) + 5, casilla[1] * pxCas + 16 - 6, pxCas - 10, 12);
						contextObject.fillStyle = emptyColor;
						contextObject.fillRect((casilla[0] * pxCas) + 8, casilla[1] * pxCas + 16 - 3, pxCas - 16, 6);
					}
				}
				break;
			case 2: //Secret Door
				contextObject.fillStyle = strokeColor;
				contextObject.font = "19px Arial bold";
				contextObject.textAlign = "center";
				contextObject.textBaseline = "middle";
				if (isBorderX(casilla) || isBorderY(casilla)) {
					if (isBorderX(casilla)) {
						contextObject.fillRect((casilla[0] * pxCas) - 1.5 + 16, casilla[1] * pxCas, 3, (pxCas / 2) - 5);
						contextObject.fillRect((casilla[0] * pxCas) - 1.5 + 16, (casilla[1] * pxCas) + (pxCas / 2) + 6, 3, (pxCas / 2) - 5);

						contextObject.save();
						contextObject.translate(casilla[0] * pxCas, casilla[1] * pxCas);
						contextObject.rotate(-Math.PI / 2);
						contextObject.fillText("S", -16.5, 16.5);
						contextObject.restore();
					} else {
						contextObject.fillRect((casilla[0] * pxCas), casilla[1] * pxCas - 1.5 + 16, (pxCas / 2) - 5, 3);
						contextObject.fillRect((casilla[0] * pxCas) + (pxCas / 2) + 6, casilla[1] * pxCas - 1.5 + 16, (pxCas / 2) - 5, 3);

						contextObject.fillText("S", (casilla[0] * pxCas) + 16, ((casilla[1] + 0.5) * pxCas + 1));
					}
				} else {
					if (!dungeonFilled[new Array(casilla[0], casilla[1] - 1)] && !dungeonFilled[new Array(casilla[0], casilla[1] + 1)]) {
						contextObject.fillRect((casilla[0] * pxCas) - 1.5 + 16, casilla[1] * pxCas, 3, (pxCas / 2) - 5);
						contextObject.fillRect((casilla[0] * pxCas) - 1.5 + 16, (casilla[1] * pxCas) + (pxCas / 2) + 6, 3, (pxCas / 2) - 5);

						contextObject.save();
						contextObject.translate(casilla[0] * pxCas, casilla[1] * pxCas);
						contextObject.rotate(-Math.PI / 2);
						contextObject.fillText("S", -16.5, 17);
						contextObject.restore();
					} else {
						contextObject.fillRect((casilla[0] * pxCas), casilla[1] * pxCas - 1.5 + 16, (pxCas / 2) - 5, 3);
						contextObject.fillRect((casilla[0] * pxCas) + (pxCas / 2) + 6, casilla[1] * pxCas - 1.5 + 16, (pxCas / 2) - 5, 3);

						contextObject.fillText("S", casilla[0] * pxCas + 16, casilla[1] * pxCas + 17);
					}
				}
				break;
			case 3: //Wall
				contextObject.fillStyle = strokeColor;
				if (isBorderX(casilla)) {
					contextObject.fillRect(((casilla[0] - 0.5) * 32) + 30.5, (casilla[1] * 32), 3, 32);
				} else {
					contextObject.fillRect((casilla[0] * 32), ((casilla[1] - 0.5) * 32) + 30.5, 32, 3);
				}
				break;
			case 4: //Trap
				contextObject.fillStyle = strokeColor;
				if (!isBorderX(casilla) && !isBorderY(casilla)) {
					contextObject.fillRect((casilla[0] * 32) + 8, (casilla[1] * 32) + 8, 16, 16);
					contextObject.fillStyle = filledColor;
					contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 10, 12, 12);
					return;
				}
				if (isBorderX(casilla)) {
					contextObject.fillRect((casilla[0] * 32) + 8, (casilla[1] * 32) + 8, 16, 16);
					contextObject.fillStyle = filledColor;
					contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 10, 12, 12);
				} else {
					contextObject.fillRect((casilla[0] * 32) + 8, (casilla[1] * 32) + 8, 16, 16);
					contextObject.fillStyle = filledColor;
					contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 10, 12, 12);
				}
				break;
			case 5: // Column
				contextObject.strokeStyle = strokeColor;
				contextObject.beginPath();
				contextObject.lineWidth = 3;
				if (!isBorderX(casilla) && !isBorderY(casilla)) {
					contextObject.arc((casilla[0] * 32) + 16, (casilla[1] * 32) + 16, 6, 0, 2 * Math.PI);
					contextObject.stroke();
					contextObject.closePath();
					return;
				}
				if (isBorderX(casilla)) {
					contextObject.arc(((casilla[0] - 0.5) * 32) + 32, (casilla[1] * 32) + 16, 6, 0, 2 * Math.PI);
				} else {
					contextObject.arc((casilla[0] * 32) + 16, ((casilla[1] - 0.5) * 32) + 32, 6, 0, 2 * Math.PI);
				}
				contextObject.stroke();
				contextObject.closePath();
				break;
			case 6: //Ventana
				contextObject.fillStyle = strokeColor;
				if (isBorderX(casilla)) {
					contextObject.fillRect(((casilla[0] - 0.5) * 32) + 30.5, (casilla[1] * 32), 3, 32);
					contextObject.fillStyle = "white";
					contextObject.fillRect(((casilla[0] - 0.5) * 32) + 31.5, (casilla[1] * 32) + 10, 1.5, 12);
				} else {
					contextObject.fillRect((casilla[0] * 32), ((casilla[1] - 0.5) * 32) + 30.5, 32, 3);
					contextObject.fillStyle = "white";
					contextObject.fillRect((casilla[0] * 32) + 10, ((casilla[1] - 0.5) * 32) + 31.5, 12, 1.5);
				}
				break;
			case 7: case 8: case 9: case 10:
				switch (dungeonObject[casilla]) {
					case 7:
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 25, 12, 3);
						contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 21, 12, 2);
						contextObject.fillRect((casilla[0] * 32) + 8, (casilla[1] * 32) + 17, 16, 2);
						contextObject.fillRect((casilla[0] * 32) + 6, (casilla[1] * 32) + 13, 20, 2);
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 9, 24, 2);
						break;

					case 8:
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 4, 12, 3);
						contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 9, 12, 2);
						contextObject.fillRect((casilla[0] * 32) + 8, (casilla[1] * 32) + 13, 16, 2);
						contextObject.fillRect((casilla[0] * 32) + 6, (casilla[1] * 32) + 17, 20, 2);
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 21, 24, 2);
						break;

					case 9:
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 9, (casilla[1] * 32) + 4, 2, 24);
						contextObject.fillRect((casilla[0] * 32) + 13, (casilla[1] * 32) + 6, 2, 20);
						contextObject.fillRect((casilla[0] * 32) + 17, (casilla[1] * 32) + 8, 2, 16);
						contextObject.fillRect((casilla[0] * 32) + 21, (casilla[1] * 32) + 10, 2, 12);
						contextObject.fillRect((casilla[0] * 32) + 25, (casilla[1] * 32) + 10, 3, 12);
						break;

					case 10:
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 10, 3, 12);
						contextObject.fillRect((casilla[0] * 32) + 9, (casilla[1] * 32) + 10, 2, 12);
						contextObject.fillRect((casilla[0] * 32) + 13, (casilla[1] * 32) + 8, 2, 16);
						contextObject.fillRect((casilla[0] * 32) + 17, (casilla[1] * 32) + 6, 2, 20);
						contextObject.fillRect((casilla[0] * 32) + 21, (casilla[1] * 32) + 4, 2, 24);
						break;
				}
				break;
			case 11: case 12: case 13: case 14: //Bajan
				switch (dungeonObject[casilla]) {
					case 11:
						contextObject.fillStyle = interColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 4, 24, 24);
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 25, 24, 3);
						contextObject.fillRect((casilla[0] * 32) + 6, (casilla[1] * 32) + 21, 20, 2);
						contextObject.fillRect((casilla[0] * 32) + 8, (casilla[1] * 32) + 17, 16, 2);
						contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 13, 12, 2);
						contextObject.fillRect((casilla[0] * 32) + 12, (casilla[1] * 32) + 9, 8, 2);
						break;

					case 12:
						contextObject.fillStyle = interColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 4, 24, 24);
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 4, 24, 3);
						contextObject.fillRect((casilla[0] * 32) + 6, (casilla[1] * 32) + 9, 20, 2);
						contextObject.fillRect((casilla[0] * 32) + 8, (casilla[1] * 32) + 13, 16, 2);
						contextObject.fillRect((casilla[0] * 32) + 10, (casilla[1] * 32) + 17, 12, 2);
						contextObject.fillRect((casilla[0] * 32) + 12, (casilla[1] * 32) + 21, 8, 2);
						break;

					case 13:
						contextObject.fillStyle = interColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 4, 24, 24);
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 25, (casilla[1] * 32) + 4, 3, 24);
						contextObject.fillRect((casilla[0] * 32) + 21, (casilla[1] * 32) + 6, 2, 20);
						contextObject.fillRect((casilla[0] * 32) + 17, (casilla[1] * 32) + 8, 2, 16);
						contextObject.fillRect((casilla[0] * 32) + 13, (casilla[1] * 32) + 10, 2, 12);
						contextObject.fillRect((casilla[0] * 32) + 9, (casilla[1] * 32) + 12, 2, 8);
						break;

					case 14:
						contextObject.fillStyle = interColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 4, 24, 24);
						contextObject.fillStyle = strokeColor;
						contextObject.fillRect((casilla[0] * 32) + 4, (casilla[1] * 32) + 4, 3, 24);
						contextObject.fillRect((casilla[0] * 32) + 9, (casilla[1] * 32) + 6, 2, 20);
						contextObject.fillRect((casilla[0] * 32) + 13, (casilla[1] * 32) + 8, 2, 16);
						contextObject.fillRect((casilla[0] * 32) + 17, (casilla[1] * 32) + 10, 2, 12);
						contextObject.fillRect((casilla[0] * 32) + 21, (casilla[1] * 32) + 12, 2, 8);
						break;
				}
				break;
		}
		if (dungeonObject[casilla] > 100) {
			contextObject.fillStyle = "black";
			contextObject.font = "28px Arial bold";
			contextObject.textAlign = "center";
			contextObject.textBaseline = "middle";
			contextObject.fillText("" + (dungeonObject[casilla] - 100), (casilla[0] * 32) + 16.5, (casilla[1] * 32) + 17.5);
			if (selectedTool == "key") {
				openFullKey(casilla);
			}
		}
	}


	// ------------------------
	function showAllKeys() {
		var dump = "";
		for (var key in fullKeys) {
			if (fullKeys.hasOwnProperty(key)) {
				dump = dump + "<p>" + key + " : " + fullKeys[key] + "</p>";
			}
		}
		document.getElementById("AllKeysDiv").innerHTML = '<button onclick="closeAllKeys()" style="float:right; ">Close</button></br>' + dump;
		document.getElementById("AllKeysDiv").style.display = "block";
	}

	function closeAllKeys() {
		document.getElementById("AllKeysDiv").style.display = "none";
	}

	function openFullKey(casilla) {
		if (dungeonObject[casilla] < 1) {
			return;
		}
		var key = parseInt(dungeonObject[casilla]) - 100;
		if (!fullKeys.hasOwnProperty(key)) {
			fullKeys[key] = "";
		}
		if (parseInt(dungeonObject[casilla]) < 100) {
			return;
		}
		console.log("key = " + key);
		currentKey = key;
		console.log(fullKeys[key]);
		document.getElementById("editKeysInput").value = fullKeys[key];
		document.getElementById("editKeys").style.display = "block";
		if (casilla[0] * 32 > window.innerWidth / 2) {
			something = document.getElementById("editKeys").offsetWidth;
			document.getElementById("editKeys").style.left = "" + ((casilla[0] * 32) - document.getElementById("editKeys").offsetWidth);
		} else {
			document.getElementById("editKeys").style.left = "" + (casilla[0] * 32);
		}
		document.getElementById("editKeys").style.top = "" + (casilla[1] * 32);
	}

	function saveKey() {
		console.log(document.getElementById("editKeysInput").value + " saved on " + currentKey);
		fullKeys[currentKey] = document.getElementById("editKeysInput").value;
		if (document.getElementById("AllKeysDiv").style.display == "block") {
			showAllKeys();
		}
		closeKeyEdit();
	}

	function closeKeyEdit() {
		document.getElementById("editKeys").style.display = "none";
		document.getElementById("editKeysInput").innerHTML = "";
	}

	// Dungeon eraser
	// ------------------------
	function dungeonEraser(logUndo = true) {
		if (logUndo) {
			undoArray.push(new Array("dun", casillaSeleccionada, dungeonFilled[casillaSeleccionada]));
		}
		dungeonFilled[casillaSeleccionada] = false;
		actualizarCasilla(casillaSeleccionada);

	}

	// Small eraser
	// ------------------------
	function smallEraser(logUndo = true) {

		tempUndo = new Array();
		var squares = [casillaSeleccionada];
		tempUndo.push(new Array("dun", casillaSeleccionada, dungeonFilled[casillaSeleccionada]));
		dungeonEraser(false);


		squares.push(new Array(casillaSeleccionada[0] - 0.5, casillaSeleccionada[1]));
		squares.push(new Array(casillaSeleccionada[0] + 0.5, casillaSeleccionada[1]));
		squares.push(new Array(casillaSeleccionada[0], casillaSeleccionada[1] - 0.5));
		squares.push(new Array(casillaSeleccionada[0], casillaSeleccionada[1] + 0.5));

		squares.forEach((square, i) => {
			if (dungeonObject[square] != 0) {
				tempUndo.push(new Array("obj", square, dungeonObject[square]));
			}
			actualizarObjeto(square, 0);
		});

		if (logUndo) {
			if (undoArray.length > 40) {
				undoArray.shift();
			}
			undoArray.push(tempUndo);
		}

	}

	// Big eraser
	// ------------------------
	function bigEraser() {

		var squares = [casillaSeleccionada];
		if (casillaSeleccionada[1] != 0) {
			squares.push(new Array(casillaSeleccionada[0], casillaSeleccionada[1] - 1));
			if (casillaSeleccionada[0] != 0) {
				squares.push(new Array(casillaSeleccionada[0] - 1, casillaSeleccionada[1] - 1));
			}
			if (casillaSeleccionada[0] != numCasX) {
				squares.push(new Array(casillaSeleccionada[0] + 1, casillaSeleccionada[1] - 1));
			}
		}
		if (casillaSeleccionada[1] != numCasY) {
			squares.push(new Array(casillaSeleccionada[0], casillaSeleccionada[1] + 1));
			if (casillaSeleccionada[0] != 0) {
				squares.push(new Array(casillaSeleccionada[0] - 1, casillaSeleccionada[1] + 1));
			}
			if (casillaSeleccionada[0] != numCasX) {
				squares.push(new Array(casillaSeleccionada[0] + 1, casillaSeleccionada[1] + 1));
			}
		}
		if (casillaSeleccionada[0] != 0) {
			squares.push(new Array(casillaSeleccionada[0] - 1, casillaSeleccionada[1]));
		}
		if (casillaSeleccionada[0] != numCasX) {
			squares.push(new Array(casillaSeleccionada[0] + 1, casillaSeleccionada[1]));
		}
		tempUndo = new Array();
		squares.forEach((square, i) => {
			if (dungeonObject[square] != 0) {
				tempUndo.push(new Array("obj", square, dungeonObject[square]));
			}
			tempUndo.push(new Array("dun", square, dungeonFilled[square]));
			casillaSeleccionada = square;
			smallEraser(false);
		});
		if (undoArray.length > 40) {
			undoArray.shift();
		}
		undoArray.push(tempUndo);

	}

	// Object eraser
	// ------------------------
	function objectEraser(logUndo = true) {
		if (logUndo) {
			undoArray.push(new Array("obj", casillaSeleccionada, dungeonObject[casillaSeleccionada]));
		}
		actualizarObjeto(casillaSeleccionada, 0);

	}

	// Exporter
	//--------------------------
	function exporter() {
		let filled = JSON.stringify(dungeonFilled);
		let objects = JSON.stringify(dungeonObject);
		let keys = JSON.stringify(fullKeys);
		var textToSave = filled + "----------" + objects + "----------" + keys;

		var hiddenElement = document.createElement('a');

		hiddenElement.href = 'data:attachment/text,' + encodeURI(textToSave);
		hiddenElement.target = '_blank';
		hiddenElement.download = 'donjson.wd';
		hiddenElement.click();
	}

	function importer(file) {

		const reader = new FileReader();

		reader.addEventListener("load", () => {
			// this will then display a text file
			dungeonFilled = JSON.parse(reader.result.split('----------')[0]);
			dungeonObject = JSON.parse(reader.result.split('----------')[1]);
			if (reader.result.split('----------').length > 2) { // Esto da compatibilidad con mapas viejos que no tienen las keys guardadas.
				fullKeys = JSON.parse(reader.result.split('----------')[2]);
			}
			cargarDungeon();
		}, false);

		if (file) {
			reader.readAsText(file);
		}
	}

	// Interface buttons functions
	//-------------------------
	function importerButton() {

		let input = document.createElement('input');
		input.type = 'file';
		input.accept = '.wd';
		input.onchange = _this => {
			let files = Array.from(input.files);
			importer(files[0]);
		};
		input.click();
	}

	function download() {


		var newCanvas = document.createElement('canvas');
		var ctx = newCanvas.getContext('2d');
		newCanvas.width = document.getElementById("dungeonC").width;
		newCanvas.height = document.getElementById("dungeonC").height;

		ctx.beginPath();
		ctx.drawImage(document.getElementById("dungeonC"), 0, 0, newCanvas.width, newCanvas.height);
		ctx.closePath();


		ctx.beginPath();
		ctx.drawImage(document.getElementById("objects"), 0, 0, newCanvas.width, newCanvas.height);
		ctx.closePath();


		var link = document.createElement('a');
		link.download = 'dungeon.png';
		link.href = newCanvas.toDataURL()
		link.click();



	}

	function changeIColor() {
		interColor = document.getElementById("interColor").value
		document.getElementById("interColor").style.border = "3px solid " + interColor
		cargarDungeon();
	}

	function changeGColor() {
		gridColor = document.getElementById("gridColor").value
		document.getElementById("gridColor").style.border = "3px solid " + gridColor
		cargarDungeon();
	}

	function changeFColor() {
		filledColor = document.getElementById("filledColor").value
		document.getElementById("filledColor").style.border = "3px solid " + filledColor
		cargarDungeon();
	}

	function changeEColor() {
		emptyColor = document.getElementById("emptyColor").value
		document.getElementById("emptyColor").style.border = "3px solid " + emptyColor
		cargarDungeon();
	}

	function changeSColor() {
		strokeColor = document.getElementById("strokeColor").value
		document.getElementById("strokeColor").style.border = "3px solid " + strokeColor
		cargarDungeon();
	}

	function ToggleGrid() {
		if (document.getElementById("casillero").style.display == "none") {
			document.getElementById("casillero").style.display = "inherit";
		} else {
			document.getElementById("casillero").style.display = "none";
		}
		cargarDungeon();
	}

	function ToggleStyles() {
		if (document.getElementById("estilos").style.display == "none") {
			document.getElementById("estilos").style.display = "flex";
		} else {
			document.getElementById("estilos").style.display = "none";
		}
	}

	function ToggleModifiers() {
		if (document.getElementById("modifiersBox").style.display == "none") {
			document.getElementById("modifiersBox").style.display = "block";
			document.getElementById("modifiersTitle").innerText = "+ Hide Modifiers +";
		} else {
			document.getElementById("modifiersBox").style.display = "none";
			document.getElementById("modifiersTitle").innerText = "+ Show Modifiers +";
		}
	}

	function ToggleGridLines() {
		showGridLine = !showGridLine;
		cargarDungeon();
	}

	function paintToken() {
		var token = tokens[parseInt(document.querySelector('input[name="subTokens"]:checked').value)]
		if (token.active) {
			contextToken.clearRect((token.casilla[0] * 32), (token.casilla[1] * 32), 32, 32);
		}
		token.casilla = casillaSeleccionada;
		token.active = true;
		token.name = document.getElementById("t" + document.querySelector('input[name="subTokens"]:checked').value + "T").value;
		contextToken.beginPath();
		contextToken.fillStyle = token.color;
		contextToken.strokeStyle = token.color;
		contextToken.lineWidth = 4;
		contextToken.arc((casillaSeleccionada[0] * 32) + 16, (casillaSeleccionada[1] * 32) + 16, 14, 0, 2 * Math.PI);
		contextToken.stroke();
		contextToken.font = "21px Arial bold";
		contextToken.textAlign = "center";
		contextToken.textBaseline = "middle";
		contextToken.fillText(token.name, (casillaSeleccionada[0] * 32) + 16, (casillaSeleccionada[1] * 32) + 16);
		contextToken.closePath();
	}

	function changeTool(tool) {
		selectedTool = tool;
		console.log(tool);
		if (tool == "token") {
			document.getElementById("subTokens").style.display = "inherit";
		} else {
			document.getElementById("subTokens").style.display = "none";
		}


		if (tool == "eraser") {
			document.getElementById("subEraser").style.display = "inherit";
		} else {
			document.getElementById("subEraser").style.display = "none";
		}


		if (tool == "stairUp") {
			document.getElementById("subSUp").style.display = "inherit";
		} else {
			document.getElementById("subSUp").style.display = "none";
		}


		if (tool == "stairDown") {
			document.getElementById("subSDown").style.display = "inherit";
		} else {
			document.getElementById("subSDown").style.display = "none";
		}
	}




	// Hotkeys
	//-----------------------------
	function KeyPress(e) {
		var evtobj = window.event ? event : e
		if (evtobj.keyCode == 90 && evtobj.ctrlKey) {
			e.preventDefault();
			undo();
		}
	}

	document.onkeydown = KeyPress;

	function rollDices(str){
		chatName=document.getElementById('chatName').value;
		if(chatName && chatName != ""){
			color = document.getElementById('chatColor').style.backgroundColor
			roll = "";
			total = 0;
			diceNumber = parseInt(str.split('d')[0]);
			dicetype = parseInt(str.split('d')[1].split('+')[0])
			for(i=0; i<diceNumber; i++){
				dice = Math.floor(Math.random()*dicetype) +1;
				total += dice;
				if(i==0){
					roll += " â†’ " + dice;
				}else{
					roll += " + " + dice;
				}
				
			}
			if(str.split('+').length>1){
				sum = parseInt(str.split('+')[1]);
				
				total += sum;
				roll += " + " + sum;
			}

			roll="<b>" + total + "</b>" + roll;

			final = "<div><div><span style='color:"+color+"'>"+chatName+":</span><span>-</span><span onclick='rollFromChat(this)'>"+str+"</span></div><div>"+roll+"</div></div>";
			
			document.getElementById('logBox').innerHTML = final + document.getElementById('logBox').innerHTML;
		}else{
			alert("Por favor introduce un nombre antes de lanzar dados.");
		}
	}

	function sendMsg(){
		chatName=document.getElementById('chatName').value;
		if(!chatName || chatName == ""){
			alert("Por favor introduce un nombre antes de lanzar dados.");
			return;
		}
		if(document.getElementById('msgInput').value != ""){
			str = document.getElementById('msgInput').value;
			console.log(str);
		}else{
			return;
		}
		
		if(str[0] == '/'){
			rollDices(str.slice(1));
		}else{
			color = document.getElementById('chatColor').style.backgroundColor
			final = "<div><div><span style='color:"+color+"'>"+chatName+":</span><div style='background-color:black; padding-left:10px; height:1px; width:100%;'></div></div><div>"+str+"</div></div>";
		}
		document.getElementById('logBox').innerHTML = final + document.getElementById('logBox').innerHTML;
		document.getElementById('msgInput').value = "";
	}

	function rollFromChat(str){
		rollDices(str.innerText);
	}

	function nametoCookie(){
		document.cookie = "chatName="+document.getElementById('chatName').value+"; expires=Fri, 31 Dec 9999 23:59:59 GMT";
		document.getElementById('saveName').style.display = "none";
	}

	document.querySelector("#chatName").addEventListener("input", toggleNameSave);
	function toggleNameSave(){
		document.getElementById('saveName').style.display = "block";
	}

	function getCookie(name) {
		function escape(s) { return s.replace(/([.*+?\^$(){}|\[\]\/\\])/g, '\\$1'); }
		var match = document.cookie.match(RegExp('(?:^|;\\s*)' + escape(name) + '=([^;]*)'));
		return match ? match[1] : null;
	}

	function changeNameColor(){
		colorArr = ["black", "purple", "red", "green", "olive", "teal", "violet", "slategray", "saddlebrown", "royalblue"];
		newIndex = colorArr.indexOf(document.getElementById('chatColor').style.backgroundColor) + 1;
		if(newIndex == colorArr.length){
			newIndex = 0;
		}
		document.getElementById('chatColor').style.backgroundColor = colorArr[newIndex];
		document.cookie = "chatColor="+colorArr[newIndex]+"; expires=Fri, 31 Dec 9999 23:59:59 GMT";
	}

	drawBoard();
	if(getCookie("chatName")){
		document.getElementById('chatName').value = getCookie("chatName");
		document.getElementById('saveName').style.display = "none";
	}
	if(getCookie("chatColor")){
		document.getElementById('chatColor').value = getCookie("chatColor");
	}

</script>

<style>
	#chatName{
		width:65%;
		text-align:center;
	}

	#modifiersBox{
		display:none;
	}

	#modifiersBox > div{
		display:flex;
		justify-content: space-between;
	}

	#modifiersBox > div > div:first-child{
		display:flex;
		justify-content: space-between;
	}

	#modifiersBox > div > div:first-child{
		display:flex;
		justify-content: space-between;
	}
	
	#rollBox{
		display:flex;
		justify-content: space-between;
	}

	#rollBox button{
		width:31px;
	}

	#chatBox{
		margin:15px 0px;
		display:flex;
	}

	#chatBox button{
		margin-left:5px;
		width:max-content;
		font-weight: bold;
	}

	#logBox{
		position:relative;
		box-sizing: border-box;
		flex:auto;
		width:calc(100%);
		border:2px solid black;
		overflow-y: scroll;
		margin-bottom:25px;
		flex-direction: column-reverse;
	}

	#logBox > div{
		padding:8px;
	}

	#logBox > div:first-child{
		margin-top:30px;
	}

	#logBox > div > div:last-child{
		padding-left:10px;
		padding-top:3px;
	}
	#logBox > div > div:first-child{
		display:flex;
		justify-content:space-between;
		align-items:center;
	}

	#logBox b{
		font-size:large;
	}

	#logBox > div > div:first-child > span:last-child{
		color:blue;
		cursor:pointer;
	}

	#logBox > div:nth-child(odd){
		background-color: lightgrey;
	}

	#logBoxTop{
		margin-bottom: -26px;
		max-height: min-content;
		text-align: center;
		padding: 2px;
		width: calc(100% - 26px);
		background-color: white;
		cursor: pointer;
		border: 2px solid black;
		font-weight: bold;
		z-index: 999;
	}

</style>